The design of the Budgeter application follows a modular, object-oriented architecture intended to separate the graphical interface, business logic, persistent storage, and user interaction flows into clearly defined components. The goal of this design is to ensure that the system is easy to maintain, extend, and reason about as additional budgeting features are added over time. At the highest level, the project is organized into three main areas: the core data models contained in budgeter_core.py, the graphical user interface contained in budgeter_gui.py, and the program entry point in main.py. Supplementary components such as dialogs, helper widgets, and persistent JSON storage are also included in the design.
The application’s interface is built using PyQt6 and follows a grid-based dashboard layout. The window is divided into a 3×3 grid that anchors all major components. The top-left cell contains the application branding, including the logo and “Budgeter” title. The top-right cell contains a menu section designed for future configuration features and currently displays a placeholder “Work In Progress” message. The central cells form the core of the application. The large region spanning cells (1,2) and (2,2) is dedicated to the Main Goal card, which displays the user’s selected primary financial goal using a circular progress indicator, textual summary, and an overall balance section. The top-middle cell and bottom-middle cell are reserved for future analytics panels such as Transaction Summary and Spending Trends.
The design of the Main Goal card is one of the central elements of the interface. It consists of several internal components arranged using nested layouts. The header displays the label “Main Goal:” followed by the active goal’s name. Directly beneath it is a small descriptive subtitle. The center portion of the card contains a two-column layout in which the left side holds a custom circular progress bar widget implemented in PyQt6’s painting system, and the right side holds textual information related to the goal’s savings progress. The right column also includes the Overall Balance section, which shows the user’s current balance in a large font size and offers an “Edit” button to update the value manually. At the bottom of the card, a horizontally aligned button row allows the user to add income or expenses, each of which triggers a transaction input dialog containing fields for the amount, category, and optional note.
Goals are represented in the system using a simple data class named Goal, defined in budgeter_core.py. This class stores the goal’s name, current saved amount, and target amount and provides a helper method to compute remaining value toward the target. All goal-related behavior is controlled through the graphical interface in budgeter_gui.py. Goals are persisted in JSON format inside data/goals.json, allowing budget progress to remain intact between program sessions. Editing of goals is handled through a dedicated dialog window that allows modifying the goal name and financial amounts. Deleting a goal removes it both from the display and from persistent storage. The design ensures that each goal is represented visually through a GoalRowWidget, a custom widget that displays a title, progress bar, percentage, and an edit button. Clicking any goal row updates the Main Goal card accordingly.
The Upcoming Bills component follows a similar design philosophy. Bills are stored as dictionaries containing a descriptive title and amount and are persisted in data/bills.json. The Upcoming Bills panel is located in the bottom-left cell of the grid and displays either a centered “Add / edit upcoming bills” message when no bills exist or a sequence of BillRowWidget objects when bills are present. Each row is represented by a simple horizontal layout containing a colored circular marker, the bill name, and the corresponding amount. Editing or deleting a bill is accomplished through the BillEditDialog, which supports both creating and removing bill entries. The design of this panel intentionally avoids nested card widgets inside the card container for visual simplicity.
Transactions are handled through the TransactionDialog, which is reused for both income and expense operations. A transaction consists of an amount, a category selected from a predefined list, and an optional note. These transactions contribute immediately to the user’s overall balance. Although the current version stores transactions in memory only, the system’s design anticipates storing them persistently and using them to populate the Transaction Summary panel and future analytics in the Spending Trend panel. Because the transaction model is intentionally decoupled from the GUI, these extensions can be added without restructuring existing components.
The application’s lifecycle is controlled through the BudgeterWindow class, which coordinates loading data at startup, updating the display, handling user actions, and saving data upon exit. When the window closes, both goals and bills are serialized back into JSON files. The GUI relies heavily on PyQt6’s layout system, including vertical and horizontal boxes, stretches, and spacings, to achieve a polished and adaptable interface. Custom widgets such as the circular progress bar and row widgets demonstrate the ability to extend Qt’s base classes for specific visual functionality. The project also includes unit tests—primarily focusing on the data model components—to verify correctness for goal calculations and structure.
Overall, this design achieves a modular, extensible, and visually structured budgeting application. The separation of concerns between the data layer, GUI layer, and persistent storage layer ensures that new features such as detailed analytics, category-based spending reports, or additional financial views can be integrated with minimal disruption. As Budgeter continues to evolve, this architecture provides a strong foundation for scaling functionality while maintaining clarity and usability.